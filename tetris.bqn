pieces â† [1â€¿1â€¿1â€¿1â‹„0â€¿0â€¿0â€¿0]â€¿[1â€¿0â€¿0â‹„1â€¿1â€¿1]â€¿[0â€¿0â€¿1â‹„1â€¿1â€¿1]â€¿[1â€¿1â‹„1â€¿1]â€¿[0â€¿1â€¿1â‹„1â€¿1â€¿0]â€¿[1â€¿1â€¿0â‹„0â€¿1â€¿1]â€¿[0â€¿1â€¿0â‹„1â€¿1â€¿1]
x â† y â† r â† 0                          # x, y, rotation
sz â† 20â€¿10                             # Field size
pcs â† szâ¥Š0                             # Placed pieces
pc â† â€¢rand.Range â‰ pieces               # Current piece index
P â† {szâ†‘â‰âˆ˜âŒ½âŸ(4|ğ•¨) ğ•©âŠ‘pieces}            # Field with piece index ğ•© placed to 0,0, rotated ğ•¨ times to left
M â† {yâ€¿xğ•Šp:                            # Move piece to ğ•¨ (y,x)
  Syâ€¿Sx â† {ğ•©â—¶Â«â€¿Â»}Â¨>âŸœ0 yâ€¿x
  SyâŸy (SxâŒ¾â‰)âŸ(|x) p
}
g â† yâ€¿x M r P pc                       # Initial game state
FL â† Â¬âˆ§ËË˜                              # Full lines
RL â† âˆ¾Â·0âŠ¸Ã—âŒ¾âŠ‘Â·FLâŠ¸âŠ”âŠ¢                     # Remove full lines and shift the field down
Refresh â† {ğ•Š: gâ†©yâ€¿x M r P pc}          # Refresh game state to current position
Init â† {ğ•Š:                             # Initialize game state for new piece
  xâ†©yâ†©râ†©0
  pcs+â†©g â‹„ pcs RLâ†©
  pcâ†©â€¢rand.Range â‰ pieces
}
Ok â† 4âŠ¸=Â·+Â´+Ë âˆ§ {Â¬Ã— +Â´+Ë 2â‰¤pcs+ğ•©}      # Check if game state ğ•© is valid
Rst â‡ {ğ•Š: Init@ â‹„ Refresh@ â‹„ pcsâ†©szâ¥Š0} # Reset game state (new game)
End â‡ {ğ•Š: Â¬Ok g}                       # Check if the game is over
KH â‡ {ğ•Šnrâ€¿nxâ€¿ny:                       # Key handler
  nrâ€¿nxâ€¿ny+â†©râ€¿xâ€¿y
  wg â† nyâ€¿nx M nr P pc                 # Wanted game state
  {ğ•Š: râ€¿xâ€¿yâ†©nrâ€¿nxâ€¿ny â‹„ Refresh@}âŸOk wg # Update game state if wanted game state is valid
}
GameState â‡ {ğ•Š: g+pcs}
Step â‡ {ğ•Š:
  next â† (y+â†©1)â€¿x M r P pc             # Next game state
  InitâŸÂ¬ Ok next                       # Init new piece if next game state is invalid
  Refresh@                             # Update game state
}
